\documentclass[a4paper]{article}

\usepackage[spanish]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage{hyperref}

\title{Trabajo Pr\'actico 2 \\ Teoría de Lenguajes}


\author{Manuel Ferreria, Luciano Gandini, Ignacio Gleria}

\begin{document}
\maketitle


\section{El problema}
El trabajo practico n°2 consiste en realizar una gram\'atica para un lenguaje
existente (Supercollider \url{supercollider.sourceforge.net }) y realizar un parser que pueda leerlo, entenderlo
y reproducirlo. El problema esta compuesto principalmente de dos secciones:
\begin{enumerate}
    \item Construir una gram\'atica que sea interpretable usando alguno de los
        compiladores de compiladores (ANTLR, YACC, Bison, etc).
    \item Definir una semantica unida a la gram\'atica, que permita dar significado
        a las producciones, para que se simplifique el trabajo de analisis de las
        cadenas y se llegue a la reproducci\'on adecuada.
\end{enumerate}

\section{Correcciones al TP 1}
Del trabajo pr\'actico anterior al actual se cambi\'o casi en su totalidad la parte de la gram\'atica correspondiente al parser y a su vez se cambi\'o la expresi\'on que denotaba a los n\'umeros de punto flotante. Se establecieron las precedencias requeridas por el enunciado en lo relacionado a operaciones aplciadas a los buffers, operaciones aritm\'eticas y generaci\'on de buffers.
\section{Implementaci\'on}

Como habiamos definido para el TP1 una soluci\'on ELL(1), decidimos proceder con
ella para la realizacion de este TP2. Por lo tanto, la mejor herramienta con la
que contamos era ANTLR. 

La estructura que definimos cuenta con tres elementos principales
\begin{itemize}
    \item \textbf{collider.g}: La gramatica ELL(1) parseable por ANTLR,
        donde se encuentran definidas las producciones y la sem\'antica
        que se asocia.
    \item \textbf{Buffer.java}: Las operaciones que se realizan en la 
        gram\'atica invocan a los m\'etodos estaticos definidos en esta
        clase. Ac\'a se encuentran las operaciones que operan sobre el 
        buffer, los generadores y la reproducci\'on de los sonidos.
    \item \textbf{Main.java}: ANTLR genera, dada una gram\'atica, un
        par de clases que representan el Lexer y el Parser. Para
        poder reconocer una cadena, hay que instanciar estas clases
        con los strings de input. Ac\'a se las instancia para que se 
        reproduzcan durante el parseo.
\end{itemize}

Para implementar la solucion, lo primero que hicimos fue definir toda la
gr\'amatica, sin la parte de sintaxis. Para esto, nos basamos en el TP1 y
acomodamos nuestras producciones al formato de Lexer y Parser que consume ANTLR.
Para comprobar que se generaban los arboles que nosotros queriamos, utilizamos
herramientas como ANTLRWorks y los plugins de IDEA y Eclipse para intepretar 
las cadenas y ver las derivaciones. 

Luego, agregamos la instanciaci\'on de de las clases generadas por ANTLR
a una clase Main, donde nos permitio empezar a probar cadenas en un 
entorno Java, donde se iba a parsear definitivamente.

Para agregar la sem\'antica, primero tuvimos que entender como se interfaceaba
ANTLR con un lenguaje de programaci\'on (en nuestro caso Java). Luego, descubrimos
como se le agregaban valores de retorno a las producciones, para poder empezar
a pasarselos y recibirlos de m\'etodos de la clase Buffer, que hacian las cuentas
descriptas en el enunciado (\texttt{sin, expand, resample, etc}). Con esto
pudimos describir los atributos sintetizados apropiadamente

Finalmente, el \'ultimo detalle que necesitabamos era como pasar atributos a
producciones, es decir, atributos heredados. Con esto, logramos pasar
los buffers generados a los m\'etodos que los alteraban y reproducian.

\section{Programas ejemplos}
\begin{itemize}
    \item \textbf{Tambores} \texttt{ \{\{ sin(8); sin(4); sin(2); sin(1) \} * lin( 1.0, 0.0) \}.expand(12).play }
    \item \textbf{Snare drum} \texttt{ \{ \{ sin( 16, 0.9)+noise(0.1) \}*lin( 1.0, 0.1) \}.expand(12).play  }
\end{itemize}

\section{Manual de uso}
Para correr el programa, se debera compilar la gramatica con ANTLR, el Main con \texttt{javac} y luego
se lo debera ejecutar como un \texttt{jar}  de Java normal, incluyendo al jar de ANTLR. Es decir (extrayendo del
\texttt{./execute\_linux.sh}): 
\begin{verbatim}
#! /bin/bash
echo "===Compilando la gramatica==="
java -jar antlr-3.3-complete.jar collider.g;
echo "===Compilando el main==="
javac -cp .:antlr-3.3-complete.jar Main.java;
echo "===Corriendo el main==="
java -cp .:antlr-3.3-complete.jar Main;
echo "===Borrando los .class==="
rm -f *.class;
\end{verbatim}
A la linea de correr el main, tambien se le puede pasar parametros (por 
defecto corre uno de los ejemplos que estan hardcodeados en el main). 
Es decir, se lo puede invocar asi:
\begin{verbatim}

echo "===Corriendo el main con parametros==="
java -cp .:antlr-3.3-complete.jar Main "{sin(44)}.loop(30).play";
\end{verbatim}

Para probar facilmente, hicimos un prompt interprete. Basta con ejecutar
\texttt{./execute\_linux.sh}) y genera una linea de comandos donde se puede probar la gram\'atica.

\section{Manual de instalaci\'on}
Lo unico que se requiere para la instalaci\'on, es tener presente Java (1.6 basta),
y el \texttt{.jar} de antlr 3.3, que viene incluido en la entrega.

De no contarse con Java instalado, se lo podra instalar haciendo (en Debian/Ubuntu)
\hbox{\texttt{sudo apt-get install openjdk-6-jdk }}

\section{Decisiones tomadas}
La principal decision que tomamos fue la de no usar objetos adicionales para
recorrer el arbol generado por ANTLR e intepretarlo, y en vez decidimos hacer
todo lo que pedia el enunciado en la semantica. Esto, nos ocasio\'o una gram\'atica
un poco m\'as complicada de lo que podria haber sido si no hubieramos hecho esto,
pero creemos que se entiende lo suficiente y nos deja como ventaja el hecho
de que la gram\'atica quedara autocontenida y no desperdigada en la estructura
de varios archivos java distintos.


\section{Conclusiones}
Finalmente, fue bastante lo que aprendimos con estos dos trabajos practicos.
Creemos que lo m\'as importante fue el hecho de que muchas veces tenemos que
leer archivos que tienen una sintaxis definible de fondo y terminamos haciendo
siempre las mismas soluciones ad-hoc, con todos los bugs que presentan. Con
herramientas como las gr\'amaticas libres de contexto encima, podemos representar
facilmente y de manera muy clara que problema estamos resolviendo.

Otra gran ventaja que descubrimos con esto, es la posiblidad de que la herramienta
(en este caso ANTLR) genere codigo para reconocer cadenas en muchos lenguajes
diferentes (C, Python, Java, Ruby, etc.) Esto nos permite portear al menos 
esta secci\'on de la soluci\'on de una manera eficaz, sencilla y repetible. 
Adem\'as, nos evita potencialmente asumir cosas sobre como procesa el lenguaje
subyacente las cadenas. ANTLR se encarga de manipular las sutilezas y nosotros
del contenido de la cadena leida.


\section{Ap\'endice: C\'odigo}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Decisiones tomadas}
\begin{itemize}
\item Todas las funciones  pueden tomar 0, 1 o 2 parámetros, tomando valores por defecto en caso de que sean menos de 2 parámetros. En el caso de tener 0 parametros, no se escriben los paréntesis '()'.

\item El whitespace de los programas es eliminado y no considerado, con excepción del caso de las //, que eliminan lo siguiente de esa línea.

\item La gramática definida es LL(1) dado que para dos producciones con misma parte izquierda, son disjuntos los simbolos directrices generados.
\end{itemize}

\section{Lexer}

\subsection{Presunciones del funcionamiento del Lexer }
\begin{itemize}
\item Nos reemplaza los números por el token numeros usando la expresión regular definida en la regla 'num'.
\item Nos reemplaza las funciones por sus tokens correspondientes.
\item Nos elimina todo caracteres que sigue el $//$ hasta el \textbackslash$n$, incluyendo las $//$
\end{itemize}

\subsection{Configuración del Lexer }
\begin{itemize}

\item Los números los definimos con expresiones regulares:
\begin{center}
num $\equiv$ (+ $|$ - $|$ ) [[1..9][0..9]* $|$ 0 ][.[0..9]*[1..9] $|$ .0 $|$ ]
\end{center}

\item Las funciones definidas con expresiones regulares:
\begin{center}
sin $\equiv$ sin \\ 						
lin $\equiv$ [lin $|$ linear] \\
sil $\equiv$ [sil $|$ silence] \\
noi $\equiv$ [noi $|$ noise] \\
\end{center}

\item Los operandos definidos con expresiones regulares:
\begin{center}
mix $\equiv$ \& $|$ mix \\
con $\equiv$ ; $|$ con \\
add $\equiv$ + $|$ add \\
sub $\equiv$ - $|$ sub \\
mul $\equiv$ * $|$ mul \\
div $\equiv$ / $|$ div
\end{center}

\item Reducción del whitespace y eliminación de los comentarios:

\begin{center}
E $\equiv$ [//\textbackslash$w$*\textbackslash$n$ $|$ \textbackslash$s$ $|$ \textbackslash$n$ ]*  
\end{center}

\end{itemize}



\section{Definici\'on de la gram\'atica}

\subsection{Símbolos no terminales}
\begin{itemize}
\item \textbf{$V_n$} = \{S R op G F H I N M P funcion\}.
\end{itemize}


\subsection{Símbolos terminales}
\begin{itemize}
\item \textbf{$V_t$} = \{, \{ \} ( ) num expand reduce post loop fill tune play sin lin sil noi mix con add sub mul div\}.
\end{itemize}

\subsection{Símbolo distinguido}
\begin{itemize}
\item \textbf{$S$} = S 
\end{itemize}

\subsection{Producciones}
\begin{enumerate}
\item Del símbolo inicial a una lista de lista generadores con aplicaciones o generadores con aplicaciones unidos por operandos.:

\begin{itemize}
\item \textbf{S} $\Rightarrow$ \{S\}N $|$ GNR 
\item \textbf{R} $\Rightarrow$ $\lambda$ $|$ op B 
\end{itemize}

\item Las operaciones pueden ser invocadas con los símbolos o con los nombres completos:
\begin{itemize}
\item \textbf{op} $\Rightarrow$ mix $|$ con $|$ add $|$ sub $|$ mul $|$ div 
\end{itemize}


\item Los generadores pueden ser o numeros u objetos devueltos por funciones:
\begin{itemize}
\item \textbf{G} $\Rightarrow$ num $|$ funcion 
\end{itemize}

\item Las funciones según definidas en la página 2 del enunciado devuelven objetos:
\begin{itemize}
\item \textbf{funcion} $\Rightarrow$  FH 
\item \textbf{F} $\Rightarrow$ sin $|$ lin $|$ sil $|$ noi 
\item \textbf{H} $\Rightarrow$ $\lambda$ $|$ ( num I 
\item \textbf{I} $\Rightarrow$ ,num) $|$ ) 
\end{itemize}	

\item Los métodos de alteración pueden tener parámetros o no, y pueden ser encadenados:

\begin{itemize}
\item \textbf{N} $\Rightarrow$ $\lambda$ $|$ .MN 
\item \textbf{M} $\Rightarrow$ expand $|$ reduce $|$ post $|$ play P $|$ loop( num ) $|$ fill( num ) $|$ tune( num ) 
\item \textbf{P} $\Rightarrow$ $\lambda$ $|$ ( num ) 
\end{itemize}

\end{enumerate}
\end{document}
