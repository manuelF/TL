Simbolos no terminales:
Vn = {L, op, E, funcion, num, sign, digits, digs, M} 

Simbolos Terminales:
Vt = {0123456789 &;+.-*/ expand reduce post loop fill tune play sin lin linear sil silence noi noise}

Simbolo distinguido:
S = S

Presuponemos sobre el Lexer:
    -  Nos reemplaza las numeros por el token numeros usando la expresion
        regular definida en la regla 'num'
    -  Nos elimina todo caracteres que sigue el // hasta el \n, incluyendo las //

Reglas del Lexer:
    #Los numeros los definimos con expresiones regulares
        num -> (+|-| ) digitos [.digitos | ] 
        digitos -> [ [1..9][0..9]* | 0]
    
    #Reduccion del whitespace
    #Eliminacion de los comentarios
    
    E -> [//\w*\n | \s | \n]*

Producciones:



#Del simbolo inicial de una lista, o tiene una lista solamente, o tiene ademas metodos
S -> L | L .M 

#La lista de cosas pueden ser elementos, o elementos separados, o sublistas, o operaciones a sublistas
L -> #lista
L -> E | E; | E; L | { L } | { L } op { L } | { L } op E

#Las operaciones pueden ser invocadas con los simbolos o con los nombres completos
op -> & | ; | + | - | * | /
op -> mix | con | add | sub | mul | div

#Los elementos pueden ser o numeros o objetos devueltos por funciones
E -> numero | funcion

#Las funciones segun definidas en pagina 2, devuelven objetos
funcion -> 		  sin(num[,num | ]) 						
				| [lin|linear](num[, num| ]) 
				| [sil|silence][() | ]
				| [noi|noise][(num) | ]



#Los metodos de alteracion pueden tener parametros o no, y pueden ser encadenados
M -> expand | reduce | post | .Mpunto | .Mpunto M

#Los metodos que toman parametros son estos
Mpunto -> loop( digs ) | fill( digs ) | tune( sign digs ) | play(digs)



