Simbolos no terminales:
Vn = {L, op, E, funcion, num, sign, digits, digs, M} 

Simbolos Terminales:
Vt = {0123456789 &;+.-*/ expand reduce post loop fill tune play sin lin linear sil silence noi noise}

Simbolo distinguido:
S = S

Presuponemos sobre el Lexer:
    -  Nos reemplaza las numeros por el token numeros usando la expresion
        regular definida en la regla 'num'.
    -  Nos reemplaza las funciones por sus tokens correspondientes.
    -  Nos elimina todo caracteres que sigue el // hasta el \n, incluyendo las //

Reglas del Lexer:
    #Los numeros los definimos con expresiones regulares
        num -> (+|-| ) [[1..9][0..9]* | 0 ][.[0..9]*[1..9] | .0 | ] 


    #Las funciones definidas con expresiones regulares:
	sin -> sin 						
	lin -> [lin|linear]
	sil -> [sil|silence]
	noi -> [noi|noise]
    

    #Reduccion del whitespace y Eliminacion de los comentarios    
    E -> [//\w*\n | \s | \n]*

Producciones:



#Del simbolo inicial de una lista, o tiene una lista solamente, o tiene ademas metodos
S -> A ($????) 

#Aplicacion de una funcion a un buffer
A -> {B}N

#Buffer, puede ser desde un elemento a buffers aplicados entre si dentro de un espacio delimitado por corchetes
B -> ENR | {B}
R -> lambda | op B 

#Las operaciones pueden ser invocadas con los simbolos o con los nombres completos
op -> & | ; | + | - | * | /
op -> mix | con | add | sub | mul | div

#Los elementos pueden ser o numeros o objetos devueltos por funciones
E -> numero | funcion

#Las funciones segun definidas en pagina 2, devuelven objetos
funcion ->  FH
F -> sin | lin | sil | noi 
H -> lambda | ( num G
G -> ,num) | )


#Los metodos de alteracion pueden tener parametros o no, y pueden ser encadenados
M -> expandN | reduceN | postN | playPN | loop( num )N | fill( num )N | tune( num )N
P -> lambda | ( num ) 
N -> lambda | .M



